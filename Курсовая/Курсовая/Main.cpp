#include <iostream>
#include <vector>
#include <iomanip>
#include <cmath>

using namespace std;

enum Menu
{
	exit_prog,
	info,
	gauss,
	iteration
};

enum Submenu
{
	subexit,
	inform,
	input
};

// Метод Гаусса для решения СЛАУ
vector<double> solveGauss(vector<vector<double>>& A, vector<double>& b)
{
	int n = A.size();

	for (int i = 0; i < n; ++i) 
	{
		// Поиск максимального элемента в столбце
		int maxRow = i;
		for (int j = i + 1; j < n; ++j) 
		{
			if (abs(A[j][i]) > abs(A[maxRow][i])) 
			{
				maxRow = j;
			}
		}

		// Перестановка строк, чтобы максимальный элемент оказался на диагонали
		swap(A[i], A[maxRow]);
		swap(b[i], b[maxRow]);

		// Приведение матрицы к треугольному виду
		for (int j = i + 1; j < n; ++j) 
		{
			double factor = A[j][i] / A[i][i];
			for (int k = i; k < n; ++k) 
			{
				A[j][k] -= factor * A[i][k];
			}
			b[j] -= factor * b[i];
		}

		// Вывод текущих параметров
		cout << "\nШаг " << i + 1 << ":\n\n";
		cout << "Матрица A:\n\n";
		for (int k = 0; k < n; ++k) 
		{
			for (int l = 0; l < n; ++l) 
			{
				cout << std::setw(10) << A[k][l] << " ";
			}
			cout << endl;
		}
		cout << "Вектор b:" << endl;
		for (int k = 0; k < n; ++k) 
		{
			cout << b[k] << "\n";
		}
		cout << endl << endl;
	}

	// Обратный ход метода Гаусса
	vector<double> x(n);
	for (int i = n - 1; i >= 0; --i) 
	{
		double sum = 0.0;
		for (int j = i + 1; j < n; ++j) 
		{
			sum += A[i][j] * x[j];
		}
		x[i] = (b[i] - sum) / A[i][i];
	}

	return x;
}

// Метод простых итераций для решения СЛАУ
vector<double> solveIterative(vector<vector<double>>& A, vector<double>& b, double epsilon)
{
	int n = A.size();
	vector<double> x(n, 0.0);
	vector<double> xNew(n);
	double maxDiff = epsilon + 1.0;
	int iteration = 0;

	while (maxDiff > epsilon) 
	{
		for (int i = 0; i < n; ++i) 
		{
			double sum = 0.0;
			for (int j = 0; j < n; ++j) 
			{
				if (j != i) 
				{
					sum += A[i][j] * x[j];
				}
			}
			xNew[i] = (b[i] - sum) / A[i][i];
		}

		maxDiff = 0.0;
		for (int i = 0; i < n; ++i) 
		{
			double diff = abs(xNew[i] - x[i]);
			if (diff > maxDiff) 
			{
				maxDiff = diff;
			}
		}

		x = xNew;
		iteration++;

		cout << "Итерация " << iteration << ": ";
		for (int i = 0; i < n; ++i) 
		{
			cout << "x" << i << " = " << x[i] << " ";
		}
		cout << endl;

		if (iteration >= 1000) {
			// Прерывание цикла, если достигнуто максимальное количество итераций
			cout << "Максимальное число итераций достигнуто." << endl;
			break;
		}
	}

	cout << "Количество итераций: " << iteration << endl;

	return x;
}



// Ввод размеров матрицы и элементов
void inputMatrix(vector<vector<double>>& A, vector<double>& b, int n) 
{
	cout << "Введите элементы матрицы A:" << endl;
	for (int i = 0; i < n; ++i) 
	{
		cout << "Строка " << i + 1 << ": ";
		for (int j = 0; j < n; ++j) 
		{
			double element;
			cin >> element;
			A[i][j] = element;
		}
	}

	cout << "Введите элементы вектора b:" << endl;
	for (int i = 0; i < n; ++i) 
	{
		double element;
		cin >> element;
		b[i] = element;
	}
}

// Вывод решения СЛАУ
void printSolution(const vector<double>& solution) 
{
	cout << "Решение: ";
	for (double val : solution) 
	{
		cout << val << " ";
	}
	cout << endl;
}

int main()
{
	setlocale(LC_ALL, "RUS");
	size_t n;
	size_t length;
	size_t ans;
	size_t subans;
	size_t maxIterations;
	double epsilon;
	vector<vector<double>> A;
	vector<double> b;
	vector<double> xGauss;
	vector<double> xIterative;

	do
	{
		cout
			<< info << " - Общая информация\n"
			<< gauss << " - Найти значение СЛАУ методом Гаусса\n"
			<< iteration << " - Найти значение СЛАУ методом простых итераций\n"
			<< exit_prog << " - Выход из программы\n\n";

		do
		{
			cout << "Выберите действие: ";
			cin >> ans;
		} while ((ans < 0) || (ans > 4));

		system("cls");

		switch (ans)
		{
		case 0:
			cout << "\n\n\n\n\n\n\n\n\n" << endl;
			cout << "\t\t\t\t\t\tРабота завершена\n\n";
			cout << "\n\n\n\n\n\n\n\n\n" << endl;
			break;

		case 1:
			cout << "\t\t\t Обучающее пособие: Решение Систем Линейных Алгебраических Уравнений (СЛАУ)\n\n"
				"Решение Систем Линейных Алгебраических Уравнений (СЛАУ) является\n"
				"фундаментальной задачей в линейной алгебре и находит широкое применение в различных областях,\n"
				"включая математику, физику, инженерию, экономику и компьютерные науки.\n"
				"СЛАУ возникают в ситуациях, когда необходимо найти значения неизвестных переменных,\n"
				"удовлетворяющих системе линейных уравнений.\n\n"
				"Это обучающее пособие предоставляет вам введение в методы решения СЛАУ,\n"
				"а именно метод Гаусса и метод простых итераций.\n"
				"Вы научитесь использовать эти методы для эффективного нахождения решений СЛАУ любых размеров.\n\n"
				"В этом пособии вы найдете реализацию методов Гаусса и простых итераций\n"
				"на языке программирования C++. Каждый метод будет дополнен меню действий,\n"
				"позволяющим выбирать метод решения СЛАУ, вводить размеры матрицы и элементы,\n"
				"а также выводить пошаговые параметры для наглядности процесса решения.\n\n";
			cout << "СЛАУ, или система линейных алгебраических уравнений, является системой уравнений, в которой все уравнения являются линейными. Методы решения СЛАУ могут быть классифицированы как прямые и итерационные методы. Рассмотрим некоторые из них.\n\n";
			cout << "\tПрямые методы :\n";
			cout << "Метод Гаусса : Этот метод основан на применении элементарных преобразований к матрице системы для приведения ее к ступенчатому виду, а затем к диагональному виду.После этого можно легко найти значения неизвестных.\n";
			cout << "Метод LU - разложения : Этот метод основан на представлении матрицы системы в виде произведения двух матриц : верхнетреугольной(U) и нижнетреугольной(L).Решение системы сводится к последовательному решению двух систем с треугольными матрицами.\n";
			cout << "Метод Холецкого : Этот метод применим к симметричным положительно определенным матрицам.Он основан на разложении матрицы системы в произведение верхнетреугольной и нижнетреугольной матриц.Затем система сводится к последовательному решению двух систем с треугольными матрицами.\n\n";
			cout << "\tИтерационные методы :\n";
			cout << "Метод простых итераций : В этом методе система уравнений разбивается на набор уравнений, каждое из которых содержит только одну неизвестную.Значения неизвестных итеративно обновляются до тех пор, пока не будет достигнута достаточно высокая точность.\n";
			cout << "Метод Зейделя : Этот метод является модификацией метода Якоби.Он позволяет использовать новые значения неизвестных сразу же после их обновления в текущей итерации.\n";
			cout << "Метод релаксации : Этот метод комбинирует идеи методов Якоби и Зейделя.Он включает параметр релаксации, который определяет вес нового значения неизвестной при обновлении.\n";
			cout << "Метод сопряженных градиентов : Этот метод эффективен для решения больших разреженных систем СЛАУ.Он использует информацию о градиентах функции для нахождения оптимального решения.\n";
			cout << "Конечный выбор метода зависит от особенностей конкретной задачи, таких как размерность системы, разреженность матрицы и требуемая точность решения.\n\n";
			system("pause");
			system("cls");
			break;

		case 2:
			do
			{
				cout
					<< "\t" << "Выберите действие:"
					<< "\n" << inform << " - Общая информация о методе Гаусса\n"
					<< input << " - Внесение данных для решения\n"
					<< subexit << " - Выход\n\n";
				do
				{
					cout << "Ваш выбор: ";
					cin >> subans;
					cout << "\n\n";
				} while ((subans < 0) || (subans > 2));
				system("cls");

				switch (subans)
				{
				case 0:
					break;

				case 1:
					cout << "Метод Гаусса позволяет привести систему линейных уравнений к треугольному виду\n"
						"путем элементарных преобразований строк и столбцов.\n"
						"Этот метод основан на идее устранения неизвестных переменных путем приведения системы\n"
						"к эквивалентной системе с более простой структурой.\n"
						"После приведения к треугольному виду, решение СЛАУ находится с помощью обратного хода метода.\n\n";
					system("pause");
					system("cls");
					break;

				case 2:
					cout << "Для решения СЛАУ методом Гаусса необходимо, чтобы СЛАУ было приведено к виду: A*u=f, где\n\n\n"
						"\t1) A - левая часть СЛАУ (до знака =)\n\n"
						"\t2) u - приближение, которые и нужно будет найти (можно приянть за x)\n\n"
						"\t3) f - правая часть СЛАУ (после знака =), представляющая собой вектор-столбец\n\n\n";
					cout << "Введите размер матрицы: ";
					cin >> n;
					A.resize(n, vector<double>(n));
					b.resize(n);
					inputMatrix(A, b, n);
					xGauss = solveGauss(A, b);
					printSolution(xGauss);
					system("pause");
					system("cls");
					break;
				}
			} while (subans != 0);
			break;

		case 3:
			do
			{
				cout
					<< "\t" << "Выберите действие:"
					<< "\n" << inform << " - Общая информация о методе простых итераций\n"
					<< input << " - Внесение данных для решения\n"
					<< subexit << " - Выход\n\n";
				do
				{
					cout << "Ваш выбор: ";
					cin >> subans;
					cout << "\n\n";
				} while ((subans < 0) || (subans > 2));
				system("cls");

				switch (subans)
				{
				case 0:
					break;

				case 1:
					cout << "Метод простых итераций является итеративным методом, основанным на преобразовании исходной системы уравнений в систему,\n"
						"в которой каждое уравнение содержит одну неизвестную переменную.\n"
						"Итерационный процесс повторяется до тех пор, пока не будет достигнуто заданное условие остановки,\n"
						"например, заданное количество итераций или достаточно малая погрешность.\n\n";
					system("pause");
					system("cls");
					break;

				case 2:
					cout << "Для решения СЛАУ методом простых итераций необходимо, чтобы СЛАУ было приведено к виду: u = B*u+F, где\n\n"
						"\t1) Первая u - вектор приближенного решения следующей итерации\n\n"
						"\t2) B - матрица, образованная из матрицы А по формуле B = E - t*A\n"
						"\t\tE - Единичная матрица\n"
						"\t\tt(тау) - минимальное значение из диапазона [||B||;1)\n"
						"\t\tA - левая часть СЛАУ\n\n"
						"\t3) Вторая u - вектор приближенного решения текущей итерации\n\n"
						"\t4) F - правая часть СЛАУ (после знака =), представляющая собой вектор-столбец\n"
						"\t\tF находится по формуле F = t*f\n\n\n";

					cout << "Введите значение эпсилон: ";
					cin >> epsilon;

					cout << "Введите размер матрицы: ";
					cin >> n;

					A.resize(n, vector<double>(n));
					b.resize(n);
					inputMatrix(A, b, n);
					xIterative = solveIterative(A, b, epsilon);
					printSolution(xIterative);
					system("pause");
					system("cls");
					break;
				}
			} while (subans != 0);
			break;
		}
	} while (ans != 0);

	return 0;
}
